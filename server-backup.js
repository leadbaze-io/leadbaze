const express = require('express');
const cors = require('cors');
const axios = require('axios');
const { v4: uuidv4 } = require('uuid');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const { BlogAutomationService, getBlogAutomationService } = require('./services/blogAutomationService');
const blogQueueRoutes = require('./routes/blogQueue');
const blogPostsRoutes = require('./routes/blogPosts');
const { router: autoProcessRoutes } = require('./routes/autoProcess');
require('dotenv').config({ path: './config.env' });

const app = express();
const PORT = process.env.PORT || 3001;

// Security middleware

// Configurar trust proxy para rate limiting
app.set("trust proxy", 1);
app.use(helmet({
  crossOriginEmbedderPolicy: false,
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "https:"],
    },
  },
}));

// Rate limiting middleware
const createRateLimit = (windowMs, max, message) => {
  return rateLimit({
    windowMs,
    max,
    message: {
      success: false,
      error: message,
      retryAfter: Math.ceil(windowMs / 1000),
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
      console.log(`üö® Rate limit exceeded for IP: ${req.ip}, Path: ${req.path}`);
      res.status(429).json({
        success: false,
        error: message,
        retryAfter: Math.ceil(windowMs / 1000),
      });
    },
  });
};

// Rate limits espec√≠ficos - OTIMIZADOS PARA PRODU√á√ÉO
const generalLimit = createRateLimit(
  15 * 60 * 1000, // 15 minutos
  500, // 500 requests por IP (muito mais permissivo)
  'Muitas requisi√ß√µes. Tente novamente em 15 minutos.'
);

// Rate limit MUITO permissivo para dashboard
const dashboardLimit = createRateLimit(
  5 * 60 * 1000, // 5 minutos
  200, // 200 requests por IP para dashboard (muito mais permissivo)
  'Muitas requisi√ß√µes do dashboard. Tente novamente em 5 minutos.'
);

// Rate limit para processamento (ainda mais permissivo)
const processLimit = createRateLimit(
  1 * 60 * 1000, // 1 minuto
  10, // 10 processamentos por minuto
  'Muitos processamentos. Tente novamente em 1 minuto.'
);

const campaignLimit = createRateLimit(
  60 * 60 * 1000, // 1 hora
  10, // 10 campanhas por hora
  'Limite de campanhas atingido. Tente novamente em 1 hora.'
);

const qrCodeLimit = createRateLimit(
  5 * 60 * 1000, // 5 minutos
  20, // 20 tentativas de QR code
  'Muitas tentativas de QR code. Aguarde 5 minutos.'
);

// Aplicar rate limiting geral
app.use(generalLimit);

// Middleware b√°sico
app.use(express.json({ limit: '10mb' }));

// Configura√ß√£o CORS din√¢mica
const corsOrigins = process.env.CORS_ORIGIN 
  ? process.env.CORS_ORIGIN.split(',').map(origin => origin.trim())
  : ['https://leadflow-indol.vercel.app', 'http://localhost:5173'];

console.log('üîß CORS Origins configuradas:', corsOrigins);

app.use(cors({
  origin: function (origin, callback) {
    console.log('üåê Origin da requisi√ß√£o:', origin);
    
    // Permitir requisi√ß√µes sem origin (como mobile apps, Postman, etc.)
    if (!origin) return callback(null, true);
    
    if (corsOrigins.indexOf(origin) !== -1) {
      console.log('‚úÖ Origin permitida:', origin);
      callback(null, true);
    } else {
      console.log('‚ùå Origin bloqueada:', origin);
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true
}));

// Evolution API Configuration
const EVOLUTION_API_URL = process.env.EVOLUTION_API_URL;
const EVOLUTION_API_KEY = process.env.EVOLUTION_API_KEY;
function sanitizeWebhookUrl(raw) {
  if (!raw) return '';
  // remove aspas iniciais/finais e espa√ßos
  const cleaned = String(raw).trim().replace(/^['"]+|['"]+$/g, '');
  return cleaned;
}

const N8N_WEBHOOK_URL = sanitizeWebhookUrl(process.env.N8N_WEBHOOK_URL); // opcional: webhook do fluxo N8N

// Headers padr√£o para todas as requisi√ß√µes √† Evolution API
const evolutionHeaders = {
  'Content-Type': 'application/json',
  'apikey': EVOLUTION_API_KEY
};

// Middleware de logging para debug
app.use((req, res, next) => {
  console.log(`üåê [Request] ${new Date().toISOString()} - ${req.method} ${req.path}`);
  console.log(`üåê [Request] Headers:`, req.headers);
  console.log(`üåê [Request] Body:`, req.body);
  next();
});

/**
 * POST /api/dispatch-campaign
 * Recebe a campanha do frontend e repassa para o webhook do N8N
 * Body esperado: Array de objetos no formato solicitado
 */
app.post('/api/dispatch-campaign', campaignLimit, async (req, res) => {
  try {
    console.log('üîÑ Recebendo requisi√ß√£o dispatch-campaign...');
    console.log('üìç N8N_WEBHOOK_URL configurada:', N8N_WEBHOOK_URL);
    
    if (!N8N_WEBHOOK_URL) {
      console.log('‚ùå N8N_WEBHOOK_URL n√£o configurada');
      return res.status(400).json({ success: false, error: 'N8N_WEBHOOK_URL n√£o configurada no servidor' });
    }

    const payload = req.body;
    console.log('üì¶ Payload recebido:', JSON.stringify(payload, null, 2));

    if (!Array.isArray(payload) || payload.length === 0) {
      console.log('‚ùå Payload inv√°lido:', payload);
      return res.status(400).json({ success: false, error: 'Payload inv√°lido. Deve ser um array n√£o-vazio.' });
    }

    // Valida URL
    try { 
      new URL(N8N_WEBHOOK_URL);
      console.log('‚úÖ URL v√°lida:', N8N_WEBHOOK_URL);
    } catch (urlError) {
      console.log('‚ùå URL inv√°lida:', N8N_WEBHOOK_URL, urlError.message);
      return res.status(400).json({ success: false, error: 'N8N_WEBHOOK_URL inv√°lida', details: N8N_WEBHOOK_URL });
    }

    console.log('üì§ Enviando para N8N...', JSON.stringify(payload).slice(0, 500));

    const response = await axios.post(N8N_WEBHOOK_URL, payload, {
      headers: { 'Content-Type': 'application/json' },
      timeout: 120000
    });

    console.log('‚úÖ N8N respondeu com sucesso:', {
      status: response.status,
      statusText: response.statusText,
      data: response.data
    });

    return res.json({ success: true, data: response.data });
  } catch (error) {
    console.error('‚ùå Erro completo:', {
      message: error.message,
      response: error.response?.data,
      status: error.response?.status,
      stack: error.stack
    });
    return res.status(500).json({ 
      success: false, 
      error: 'Falha ao enviar campanha para N8N', 
      details: error.response?.data || error.message,
      status: error.response?.status 
    });
  }
});

/**
 * POST /api/create-instance-and-qrcode
 * Cria uma nova inst√¢ncia e retorna o QR Code
 */
app.post('/api/create-instance-and-qrcode', async (req, res) => {
  try {
    const { instanceName, userName } = req.body;
    
    if (!instanceName) {
      return res.status(400).json({
        success: false,
        error: 'instanceName √© obrigat√≥rio'
      });
    }

    console.log(`üîÑ Criando inst√¢ncia: ${instanceName}${userName ? ` para usu√°rio: ${userName}` : ''}`);
    console.log(`üåê Evolution API URL: ${EVOLUTION_API_URL}`);
    console.log(`üîë API Key configurada: ${EVOLUTION_API_KEY ? '‚úÖ' : '‚ùå'}`);

    // Verificar se a Evolution API est√° configurada
    if (!EVOLUTION_API_URL || !EVOLUTION_API_KEY) {
      console.error('‚ùå Evolution API n√£o configurada corretamente');
      return res.status(500).json({
        success: false,
        error: 'Evolution API n√£o configurada',
        details: 'EVOLUTION_API_URL ou EVOLUTION_API_KEY n√£o est√£o definidas'
      });
    }

    // 1. Criar a inst√¢ncia na Evolution API com estrutura simplificada
    console.log('üì§ Enviando requisi√ß√£o para Evolution API...');
    
    const createInstanceResponse = await axios.post(
      `${EVOLUTION_API_URL}/instance/create`,
      {
        instanceName: instanceName,
        token: uuidv4(), // Token √∫nico para a inst√¢ncia
        qrcode: true,
        integration: "WHATSAPP-BAILEYS"
      },
      { 
        headers: evolutionHeaders,
        timeout: 30000 // 30 segundos timeout
      }
    );

    console.log('‚úÖ Inst√¢ncia criada com sucesso:', createInstanceResponse.data);

    // 2. Retornar dados para o frontend
    res.json({
      success: true,
      instanceName: instanceName,
      qrCodeBase64: null, // QR Code ser√° buscado pelo frontend
      pairingCode: null,
      message: 'Inst√¢ncia criada com sucesso. Aguardando QR Code...'
    });

  } catch (error) {
    console.error('‚ùå Erro detalhado ao criar inst√¢ncia:');
    console.error('Status:', error.response?.status);
    console.error('Status Text:', error.response?.statusText);
    console.error('Data:', JSON.stringify(error.response?.data, null, 2));
    console.error('Message:', error.message);
    console.error('URL tentada:', `${EVOLUTION_API_URL}/instance/create`);
    console.error('Headers enviados:', evolutionHeaders);
    
    // Retornar erro mais espec√≠fico
    let errorMessage = 'Erro ao criar inst√¢ncia';
    let errorDetails = error.message;
    
    if (error.response?.status === 401) {
      errorMessage = 'Erro de autentica√ß√£o com Evolution API';
      errorDetails = 'Verifique a chave da API (EVOLUTION_API_KEY)';
    } else if (error.response?.status === 404) {
      errorMessage = 'Evolution API n√£o encontrada';
      errorDetails = 'Verifique a URL da Evolution API (EVOLUTION_API_URL)';
    } else if (error.response?.status === 500) {
      errorMessage = 'Erro interno da Evolution API';
      errorDetails = error.response?.data?.message || error.message;
    } else if (error.code === 'ECONNREFUSED') {
      errorMessage = 'N√£o foi poss√≠vel conectar √† Evolution API';
      errorDetails = 'Verifique se a Evolution API est√° rodando';
    }
    
    res.status(500).json({
      success: false,
      error: errorMessage,
      details: errorDetails,
      evolutionApiUrl: EVOLUTION_API_URL,
      hasApiKey: !!EVOLUTION_API_KEY
    });
  }
});

/**
 * GET /api/qrcode/:instanceName
 * Busca o QR Code de uma inst√¢ncia espec√≠fica
 */
app.get('/api/qrcode/:instanceName', qrCodeLimit, async (req, res) => {
  try {
    const { instanceName } = req.params;
    
    if (!instanceName) {
      return res.status(400).json({
        success: false,
        error: 'instanceName √© obrigat√≥rio'
      });
    }

    console.log(`üîç Buscando QR Code para inst√¢ncia: ${instanceName}`);

    // Tentar diferentes endpoints para obter o QR Code
    let qrCodeBase64 = null;
    let pairingCode = null;
    
    try {
      // Estrat√©gia 1: Endpoint padr√£o
      const qrCodeResponse = await axios.get(
        `${EVOLUTION_API_URL}/instance/connect/${instanceName}`,
        { headers: evolutionHeaders }
      );

      console.log('üì± Resposta do QR Code:', JSON.stringify(qrCodeResponse.data, null, 2));
      
      // Verificar diferentes formatos de resposta
      const qrData = qrCodeResponse.data;
      

      
      // Priorizar o campo base64 que j√° vem formatado para imagem
      if (qrData.base64 && qrData.base64.startsWith('data:image/')) {
        qrCodeBase64 = qrData.base64;
        console.log('‚úÖ QR Code encontrado no campo: base64 (formato imagem)');
      } else if (qrData.qrcode && qrData.qrcode !== '' && qrData.qrcode !== '0' && qrData.qrcode !== 0) {
        qrCodeBase64 = qrData.qrcode;
        console.log('‚úÖ QR Code encontrado no campo: qrcode');
      } else if (qrData.qrcodeBase64 && qrData.qrcodeBase64 !== '' && qrData.qrcodeBase64 !== '0' && qrData.qrcodeBase64 !== 0) {
        qrCodeBase64 = qrData.qrcodeBase64;
        console.log('‚úÖ QR Code encontrado no campo: qrcodeBase64');
      } else if (qrData.code && qrData.code !== '' && qrData.code !== '0' && qrData.code !== 0) {
        // O campo code n√£o √© base64, n√£o usar para imagem
        console.log('‚ö†Ô∏è Campo code encontrado, mas n√£o √© formato de imagem v√°lido');
      }
      
      // Se n√£o encontrou QR Code v√°lido, retornar null
      if (!qrCodeBase64) {
        console.log('‚ùå Nenhum QR Code v√°lido encontrado');
      }
      
      // Verificar pairing code
      const possiblePairingFields = ['pairingCode', 'pairing', 'code'];
      for (const field of possiblePairingFields) {
        if (qrData[field] && qrData[field] !== '') {
          pairingCode = qrData[field];
          console.log(`‚úÖ Pairing Code encontrado no campo: ${field}`);
          break;
        }
      }

    } catch (error) {
      console.log('‚ö†Ô∏è Erro ao buscar QR Code:', error.message);
    }

    res.json({
      success: true,
      instanceName: instanceName,
      qrCodeBase64: qrCodeBase64,
      pairingCode: pairingCode,
      hasQRCode: !!qrCodeBase64,
      message: qrCodeBase64 
        ? 'QR Code encontrado!'
        : 'QR Code ainda n√£o dispon√≠vel. Tente novamente.'
    });

  } catch (error) {
    console.error('Erro ao buscar QR Code:', error.response?.data || error.message);
    
    res.status(500).json({
      success: false,
      error: 'Erro ao buscar QR Code',
      details: error.response?.data || error.message
    });
  }
});

/**
 * GET /api/connection-state/:instanceName
 * Verifica o estado da conex√£o da inst√¢ncia
 */
app.get('/api/connection-state/:instanceName', async (req, res) => {
  try {
    const { instanceName } = req.params;
    
    if (!instanceName) {
      return res.status(400).json({
        success: false,
        error: 'instanceName √© obrigat√≥rio'
      });
    }

    console.log(`Verificando estado da inst√¢ncia: ${instanceName}`);

    // Consultar estado da conex√£o
    const connectionStateResponse = await axios.get(
      `${EVOLUTION_API_URL}/instance/connectionState/${instanceName}`,
      { headers: evolutionHeaders }
    );

    console.log('Estado da conex√£o:', connectionStateResponse.data);

    // Extrair o estado da resposta da Evolution API
    const state = connectionStateResponse.data?.instance?.state || connectionStateResponse.data?.state || 'unknown';

    res.json({
      success: true,
      instanceName: instanceName,
      state: state,
      message: getStateMessage(state)
    });

  } catch (error) {
    console.error('Erro ao verificar estado da conex√£o:', error.response?.data || error.message);
    
    res.status(500).json({
      success: false,
      error: 'Erro ao verificar estado da conex√£o',
      details: error.response?.data || error.message
    });
  }
});

/**
 * DELETE /api/delete-instance/:instanceName
 * Deleta uma inst√¢ncia (opcional - para limpeza)
 */
app.delete('/api/delete-instance/:instanceName', async (req, res) => {
  try {
    const { instanceName } = req.params;
    
    if (!instanceName) {
      return res.status(400).json({
        success: false,
        error: 'instanceName √© obrigat√≥rio'
      });
    }

    console.log(`Deletando inst√¢ncia: ${instanceName}`);

    const deleteResponse = await axios.delete(
      `${EVOLUTION_API_URL}/instance/delete/${instanceName}`,
      { headers: evolutionHeaders }
    );

    console.log('Inst√¢ncia deletada:', deleteResponse.data);

    res.json({
      success: true,
      message: 'Inst√¢ncia deletada com sucesso'
    });

  } catch (error) {
    console.error('Erro ao deletar inst√¢ncia:', error.response?.data || error.message);
    
    res.status(500).json({
      success: false,
      error: 'Erro ao deletar inst√¢ncia',
      details: error.response?.data || error.message
    });
  }
});

/**
 * POST /webhook/:instanceName
 * Endpoint para receber webhooks da Evolution API
 */
app.post('/webhook/:instanceName', (req, res) => {
  try {
    const { instanceName } = req.params;
    const webhookData = req.body;
    
    console.log(`üì° Webhook recebido para inst√¢ncia ${instanceName}:`, webhookData);
    
    // Verificar se √© um evento de QR Code
    if (webhookData.event === 'qrcode' || webhookData.qrcode) {
      console.log('‚úÖ QR Code recebido via webhook!');
      // Aqui voc√™ pode implementar l√≥gica para notificar o frontend
    }
    
    res.json({ success: true, message: 'Webhook recebido' });
  } catch (error) {
    console.error('Erro ao processar webhook:', error);
    res.status(500).json({ success: false, error: 'Erro ao processar webhook' });
  }
});

/**
 * GET /api/health
 * Endpoint de sa√∫de do servidor
 */
app.get('/api/health', async (req, res) => {
  const startTime = Date.now();
  
  try {
    // Verificar conectividade com servi√ßos externos
    const healthChecks = {
      server: {
        status: 'healthy',
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        version: process.version,
        platform: process.platform,
      },
      evolution_api: {
        status: 'unknown',
        url: EVOLUTION_API_URL,
        response_time: null,
      },
      n8n_webhook: {
        status: 'unknown',
        url: N8N_WEBHOOK_URL,
        response_time: null,
      },
    };

    // Testar Evolution API
    if (EVOLUTION_API_URL && EVOLUTION_API_KEY) {
      try {
        const start = Date.now();
        const response = await axios.get(`${EVOLUTION_API_URL}/manager/findInstances`, {
          headers: evolutionHeaders,
          timeout: 5000,
        });
        
        healthChecks.evolution_api.status = response.status === 200 ? 'healthy' : 'unhealthy';
        healthChecks.evolution_api.response_time = Date.now() - start;
        healthChecks.evolution_api.instances_count = response.data?.length || 0;
      } catch (error) {
        healthChecks.evolution_api.status = 'unhealthy';
        healthChecks.evolution_api.error = error.message;
        healthChecks.evolution_api.error_code = error.code;
        healthChecks.evolution_api.error_status = error.response?.status;
      }
    } else {
      healthChecks.evolution_api.status = 'not_configured';
      healthChecks.evolution_api.missing_config = {
        url: !EVOLUTION_API_URL,
        key: !EVOLUTION_API_KEY
      };
    }

    // Testar N8N Webhook
    if (N8N_WEBHOOK_URL) {
      try {
        const start = Date.now();
        // Teste b√°sico de conectividade (pode retornar erro, mas conectou)
        await axios.get(N8N_WEBHOOK_URL, { timeout: 3000 });
        healthChecks.n8n_webhook.status = 'healthy';
        healthChecks.n8n_webhook.response_time = Date.now() - start;
      } catch (error) {
        // N8N pode retornar 405 (Method Not Allowed) para GET, isso √© normal
        if (error.response?.status === 405) {
          healthChecks.n8n_webhook.status = 'healthy';
          healthChecks.n8n_webhook.response_time = Date.now() - start;
        } else {
          healthChecks.n8n_webhook.status = 'unhealthy';
          healthChecks.n8n_webhook.error = error.message;
        }
      }
    } else {
      healthChecks.n8n_webhook.status = 'not_configured';
    }

    const totalResponseTime = Date.now() - startTime;
    const overallStatus = Object.values(healthChecks).every(
      check => check.status === 'healthy' || check.status === 'not_configured'
    ) ? 'healthy' : 'degraded';

    res.json({
      success: true,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      response_time: totalResponseTime,
      environment: process.env.NODE_ENV || 'development',
      checks: healthChecks,
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      response_time: Date.now() - startTime,
      error: error.message,
    });
  }
});

/**
 * GET /api/metrics
 * M√©tricas b√°sicas do servidor
 */
app.get('/api/metrics', (req, res) => {
  const startTime = process.hrtime();
  
  res.json({
    success: true,
    timestamp: new Date().toISOString(),
    metrics: {
      uptime: process.uptime(),
      memory: {
        ...process.memoryUsage(),
        free: process.memoryUsage().heapTotal - process.memoryUsage().heapUsed,
      },
      cpu: process.cpuUsage(),
      load_average: process.platform !== 'win32' ? require('os').loadavg() : null,
      platform: {
        node_version: process.version,
        platform: process.platform,
        arch: process.arch,
      },
      environment: process.env.NODE_ENV || 'development',
    },
  });
});

/**
 * Fun√ß√£o auxiliar para mensagens de estado
 */
function getStateMessage(state) {
  const messages = {
    'open': 'WhatsApp conectado com sucesso!',
    'connecting': 'Conectando ao WhatsApp...',
    'close': 'WhatsApp desconectado',
    'disconnected': 'WhatsApp desconectado',
    'qrcode': 'Escaneie o QR Code para conectar',
    'qrRead': 'QR Code lido, conectando...',
    'ready': 'WhatsApp pronto para uso!',
    'loading': 'Carregando WhatsApp...',
    'start': 'Iniciando conex√£o...',
    'stop': 'Conex√£o parada',
    'destroy': 'Inst√¢ncia destru√≠da'
  };
  
  return messages[state] || `Estado: ${state}`;
}

// Tratamento de erros global
app.use((error, req, res, next) => {
  console.error('Erro n√£o tratado:', error);
  res.status(500).json({
    success: false,
    error: 'Erro interno do servidor'
  });
});

// =====================================================
// BLOG AUTOMATION ENDPOINTS
// =====================================================

// Middleware para verificar admin autorizado
const checkAdminAuth = (req, res, next) => {
  const userEmail = req.headers['x-user-email'];
  const automationService = getBlogAutomationService();
  
  if (!userEmail || !automationService.isAuthorizedAdmin(userEmail)) {
    return res.status(403).json({
      success: false,
      error: 'Acesso negado. Apenas administradores autorizados.'
    });
  }
  
  next();
};

// Health check do sistema de automa√ß√£o
app.get('/api/blog/automation/health', async (req, res) => {
  try {
    const automationService = getBlogAutomationService();
    const health = await automationService.healthCheck();
    
    res.json(health);
  } catch (error) {
    console.error('‚ùå Erro no health check de automa√ß√£o:', error);
    res.status(500).json({
      success: false,
      error: 'Erro no health check de automa√ß√£o'
    });
  }
});

// Obter estat√≠sticas (p√∫blico)
app.get('/api/blog/automation/stats', async (req, res) => {
  try {
    const automationService = getBlogAutomationService();
    const stats = await automationService.getStats();
    
    res.json(stats);
  } catch (error) {
    console.error('‚ùå Erro ao obter estat√≠sticas:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao obter estat√≠sticas'
    });
  }
});

// Rotas do blog queue (p√∫blicas para inser√ß√£o manual)
console.log('üîß [Server] Registrando rotas do blog...');
app.use('/api/blog/queue', blogQueueRoutes);
app.use('/api/blog', blogPostsRoutes);
app.use('/api/blog/auto', autoProcessRoutes);
console.log('‚úÖ [Server] Rotas do blog registradas com sucesso');

// Endpoints admin (requerem autentica√ß√£o) - com rate limit espec√≠fico
app.use('/api/blog/automation/admin/*', dashboardLimit, checkAdminAuth);

// Processar fila manualmente (admin) - COM RATE LIMIT ESPEC√çFICO
app.post('/api/blog/automation/admin/process', processLimit, async (req, res) => {
  console.log('üéØ [Backend] ===== RECEBENDO REQUISI√á√ÉO DE PROCESSAMENTO =====');
  console.log('‚è∞ [Backend] Timestamp:', new Date().toISOString());
  console.log('üë§ [Backend] User email:', req.headers['x-user-email']);
  console.log('üåê [Backend] IP:', req.ip);
  console.log('üìã [Backend] Headers:', JSON.stringify(req.headers, null, 2));
  
  try {
    console.log('üîß [Backend] Obtendo BlogAutomationService...');
    const automationService = getBlogAutomationService();
    console.log('‚úÖ [Backend] Servi√ßo obtido com sucesso');
    
    console.log('üöÄ [Backend] Chamando automationService.processQueue()...');
    const result = await automationService.processQueue();
    
    console.log('‚úÖ [Backend] ===== RESULTADO DO PROCESSAMENTO =====');
    console.log('üìÑ [Backend] Tipo do resultado:', typeof result);
    console.log('üìÑ [Backend] Resultado completo:', JSON.stringify(result, null, 2));
    console.log('üìÑ [Backend] result.success:', result?.success);
    console.log('üìÑ [Backend] result.processed:', result?.processed);
    console.log('üìÑ [Backend] result.errors:', result?.errors);
    console.log('üìÑ [Backend] result.details:', result?.details);
    
    console.log('üì§ [Backend] Enviando resposta para o frontend...');
    res.json(result);
    console.log('‚úÖ [Backend] Resposta enviada com sucesso');
    
  } catch (error) {
    console.error('‚ùå [Backend] ===== ERRO NO PROCESSAMENTO =====');
    console.error('‚ùå [Backend] Tipo do erro:', typeof error);
    console.error('‚ùå [Backend] Erro completo:', error);
    console.error('‚ùå [Backend] Error message:', error.message);
    console.error('‚ùå [Backend] Error stack:', error.stack);
    
    res.status(500).json({
      success: false,
      error: 'Erro ao processar fila',
      details: error.message
    });
  }
});

// Obter fila completa (admin)
app.get('/api/blog/automation/admin/queue', async (req, res) => {
  try {
    const automationService = getBlogAutomationService();
    const limit = parseInt(req.query.limit) || 50;
    const queue = await automationService.getQueue(limit);
    
    res.json(queue);
  } catch (error) {
    console.error('‚ùå Erro ao obter fila:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao obter fila'
    });
  }
});

// Processar item espec√≠fico (admin)
app.post('/api/blog/automation/admin/process/:itemId', async (req, res) => {
  try {
    const automationService = getBlogAutomationService();
    const { itemId } = req.params;
    const result = await automationService.processItem(itemId);
    
    res.json(result);
  } catch (error) {
    console.error('‚ùå Erro ao processar item:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao processar item'
    });
  }
});

// Obter configura√ß√£o (admin)
app.get('/api/blog/automation/admin/config', (req, res) => {
  try {
    const automationService = getBlogAutomationService();
    const config = automationService.getConfig();
    
    res.json({
      success: true,
      config
    });
  } catch (error) {
    console.error('‚ùå Erro ao obter configura√ß√£o:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao obter configura√ß√£o'
    });
  }
});

// Atualizar configura√ß√£o (admin)
app.put('/api/blog/automation/admin/config', (req, res) => {
  try {
    const automationService = getBlogAutomationService();
    const newConfig = req.body;
    
    automationService.updateConfig(newConfig);
    
    res.json({
      success: true,
      message: 'Configura√ß√£o atualizada com sucesso',
      config: automationService.getConfig()
    });
  } catch (error) {
    console.error('‚ùå Erro ao atualizar configura√ß√£o:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao atualizar configura√ß√£o'
    });
  }
});

// Controlar scheduler (admin)
app.post('/api/blog/automation/admin/scheduler/:action', (req, res) => {
  try {
    const automationService = getBlogAutomationService();
    const { action } = req.params;
    
    if (action === 'start') {
      automationService.startScheduler();
      res.json({
        success: true,
        message: 'Scheduler iniciado com sucesso'
      });
    } else if (action === 'stop') {
      automationService.stopScheduler();
      res.json({
        success: true,
        message: 'Scheduler parado com sucesso'
      });
    } else {
      res.status(400).json({
        success: false,
        error: 'A√ß√£o inv√°lida. Use "start" ou "stop"'
      });
    }
  } catch (error) {
    console.error('‚ùå Erro ao controlar scheduler:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao controlar scheduler'
    });
  }
});

// Obter logs (admin)
app.get('/api/blog/automation/admin/logs', async (req, res) => {
  try {
    const automationService = getBlogAutomationService();
    const limit = parseInt(req.query.limit) || 100;
    const logs = await automationService.getLogs(limit);
    
    res.json(logs);
  } catch (error) {
    console.error('‚ùå Erro ao obter logs:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao obter logs'
    });
  }
});

// Webhook para receber dados do N8N
app.post('/api/blog/automation/webhook', async (req, res) => {
  try {
    console.log('üì° Webhook N8N recebido:', req.body);
    
    const { title, content, category, date, imageurl, autor } = req.body;
    
    // Valida√ß√£o b√°sica
    if (!title || !content || !category || !date) {
      return res.status(400).json({
        success: false,
        error: 'Campos obrigat√≥rios: title, content, category, date'
      });
    }
    
    // Inserir na fila N8N
    const automationService = getBlogAutomationService();
    const result = await automationService.addToQueue({
      title,
      content,
      category,
      date,
      imageurl: imageurl || null,
      autor: autor || 'LeadBaze Team'
    });
    
    if (result.success) {
      console.log('‚úÖ Artigo adicionado √† fila:', result.data);
      res.json({
        success: true,
        message: 'Artigo adicionado √† fila com sucesso',
        data: result.data
      });
    } else {
      console.error('‚ùå Erro ao adicionar √† fila:', result.error);
      res.status(500).json({
        success: false,
        error: 'Erro ao adicionar artigo √† fila',
        details: result.error
      });
    }
    
  } catch (error) {
    console.error('‚ùå Erro no webhook N8N:', error);
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor',
      details: error.message
    });
  }
});

// Rota 404
app.use('*', (req, res) => {
  res.status(404).json({
    success: false,
    error: 'Rota n√£o encontrada'
  });
});

// Iniciar servidor
app.listen(PORT, () => {
  console.log(`üöÄ Evolution API Backend rodando na porta ${PORT}`);
  console.log(`üì± URL da Evolution API: ${EVOLUTION_API_URL}`);
  console.log(`üåê CORS Origin: ${process.env.CORS_ORIGIN}`);
  console.log(`üîß Ambiente: ${process.env.NODE_ENV}`);
  console.log(`üîó N8N Webhook URL configurada: ${N8N_WEBHOOK_URL ? '‚úÖ' : '‚ùå'}`);
  
  // Iniciar servi√ßo de automa√ß√£o do blog
  try {
    const automationService = getBlogAutomationService();
    automationService.startScheduler();
    
    // AutoPollingService dispon√≠vel mas n√£o iniciado por padr√£o
    // Para ativar: POST /api/blog/realtime/polling/start
    // const autoPollingService = getAutoPollingService();
    // console.log('üîÑ AutoPollingService dispon√≠vel (n√£o iniciado por padr√£o)');
    
    // Iniciar servi√ßo de polling autom√°tico
    const { getPollingService } = require("./services/pollingService");
    const pollingService = getPollingService();
    pollingService.start();
    
    console.log('ü§ñ Blog Automation Service iniciado');
    console.log('üìß Admin autorizado: creaty12345@gmail.com');
  } catch (error) {
    console.error('‚ùå Erro ao iniciar Blog Automation Service:', error);
  }
});

module.exports = app; 